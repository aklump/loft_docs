var tipuesearch = {"pages":[{"title":"Changelog","text":"  All notable changes to this project will be documented in this file.  The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.  [Unreleased]  [1.0.21] - 2019-06-07  Changed   Updated tests to work with PHPUnit 6.x, 7.x  ","tags":"","url":"CHANGELOG.html"},{"title":"FilePath: A Better Way to Work With Files and Folders","text":"  Working with Directories  Create a directory and all parents  Either of these will work.  The second, though, returns a new instance object.  FilePath::ensureDir('foo\/bar\/baz'); $fp = FilePath::create('foo\/bar\/baz')-&gt;parents();   Create a hidden directory  In this case you have to bypass the automatic determination of a file or directory based on the format of the path, so instead be explicit that you want a directory.  list($path_to_dir) = FilePath::ensureDir('foo\/bar\/.baz', NULL, TRUE); $hidden_dir_object = FilePath::create('foo\/bar\/.baz', NULL, [   'type' =&gt; FilePath::TYPE_DIR, ])-&gt;parents();   List files and folders  $dir = FilePath::create('foo\/bar\/baz'); $filesAndFolders = $dir-&gt;children()-&gt;all(); $files = $dir-&gt;children()-&gt;justFiles()-&gt;all(); $dirs = $dir-&gt;children()-&gt;justDirs()-&gt;all();   List files and folders recursively  $dir = FilePath::create('foo\/bar\/baz'); $filesAndFolders = $dir-&gt;descendents()-&gt;all(); $files = $dir-&gt;descendents()-&gt;justFiles()-&gt;all(); $dirs = $dir-&gt;descendents()-&gt;justDirs()-&gt;all();   List recursively, limit to two levels  $dir = FilePath::create('foo\/bar\/baz'); $filesAndFolders = $dir-&gt;descendents(2)-&gt;all(); $files = $dir-&gt;descendents(2)-&gt;justFiles()-&gt;all(); $dirs = $dir-&gt;descendents(2)-&gt;justDirs()-&gt;all();   List pdf files recursively  $dir = FilePath::create('foo\/bar\/baz'); $files = $dir-&gt;descendents('\/\\.pdf$\/')-&gt;justFiles()-&gt;all();   List pdf files recursively limit to 1 level  $dir = FilePath::create('foo\/bar\/baz');  \/\/ Notice the order of the limit level doesn't matter. $files = $dir-&gt;descendents('\/\\.pdf$\/', 1)-&gt;justFiles()-&gt;all(); $files = $dir-&gt;descendents(1, '\/\\.pdf$\/')-&gt;justFiles()-&gt;all();  \/\/ or just us children() $files = $dir-&gt;children('\/\\.pdf$\/')-&gt;justFiles()-&gt;all();   List all but pdf files recursively  $dir = FilePath::create('foo\/bar\/baz');  \/\/ When two strings are sent as arguments, the first is use to match and the second to exclude; empty strings are ignored. $files = $dir-&gt;descendents('', '\/\\.pdf$\/')-&gt;justFiles()-&gt;all();   List any file matching foo unless it ends with .txt  $dir = FilePath::create('foo\/bar\/baz'); $files = $dir-&gt;descendents('\/foo\/', '\/\\.txt\/')-&gt;justFiles()-&gt;all();   Working with Files  When you instantiate with a filepath, the file will not be created, but all the parent directories will be created automatically if you attempt to write to the filepath.  If you do not want this, you must use the parents = false option to the constructor.  Attributes of a file  $f = FilePath::create('\/parent\/dir\/hello_world.txt');  ...  $path = $f-&gt;getPath(); $extension = $f-&gt;getExtension(); $fname = $f-&gt;getFileName(); $basename = $f-&gt;getBaseName(); $basename = $f-&gt;getId(); $directory = $f-&gt;getDirName(); $mime = $f-&gt;getMimeType(); $hash = $f-&gt;getHash();   Create Empty Files  \/\/ The parent $dir into which you will create files. $dir = FilePath::create('\/parent\/dir\/ect\/ory');  $file1 = $dir-&gt;to('do.txt')-&gt;save(); $file2 = $dir-&gt;to('re.txt')-&gt;save(); $file3 = $dir-&gt;to('mi.txt')-&gt;save();   Create Many Files With Same Content  \/\/ $dir is not written to disk, but exists as a \"stamp\" or \"template\". $dir = FilePath::create('\/parent\/dir\/ect\/ory'); $dir-&gt;put('lorem ipsum');  \/\/ The save method will \"apply the stamp\" to disc with the contents of the stamp. $file1 = $dir-&gt;to('do.txt')-&gt;save(); $file2 = $dir-&gt;to('re.txt')-&gt;save(); $file3 = $dir-&gt;to('mi.txt')-&gt;save();   Create Many Files With Different Content  $dir = FilePath::create('\/parent\/dir\/ect\/ory');  $file1 = $dir-&gt;put('lorem')-&gt;to('do.txt')-&gt;save(); $file2 = $dir-&gt;put('ipsum')-&gt;to('re.txt')-&gt;save(); $file3 = $dir-&gt;put('dolar')-&gt;to('mi.txt')-&gt;save();   Writing to a File  $file = FilePath::create('\/parent\/dir\/hello_world.txt'); $path = $file-&gt;put('hello world')-&gt;save()-&gt;getPath();  \/\/ The contents of the file are already in memory so load() is not needed. $contents = $file-&gt;get();   Reading a File  $contents = FilePath::create('\/parent\/dir\/hello_world.txt')   -&gt;load()   -&gt;get();   By passing a directory and an extension, a temporary filename will be created automatically.  Working with a time-based name file  $file = FilePath::create('\/foo\/bar\/baz\/' . FilePath::dateName('json')); \/\/  $file-&gt;getPath() === \/foo\/bar\/baz\/2017-11-17T00-55-20Z.json   Delete a file  $file = FilePath::create('\/foo\/bar.txt')-&gt;destroy();   Rename a file  $file = FilePath::create('\/foo\/bar.txt')-&gt;rename('new_basename.txt);   Copying Files  Copy a file  $source = FilePath::create(ROOT . '\/quick_start.json'); $destination = FilePath::create(getcwd() . '\/sitemap.json')   -&gt;copyFrom($source);   Copy a file from one directory to another  $destination_dir = FilePath::create('\/dir\/where\/file\/end\/up'); $destination_dir-&gt;copyFrom('\/source\/file.md');  $another_file = FilePath::create('\/source2\/file2.txt'); $destination_dir-&gt;copyFrom($another_file);   Copy and rename a file from one dir to another  $destination_dir = FilePath::create('\/dir\/where\/file\/end\/up'); $destination_dir-&gt;copyFrom('\/source\/file.md')-&gt;rename('renamed.md');   Move a file from one directory to another  $destination_dir = FilePath::create('\/dir\/where\/file\/end\/up'); $destination_dir-&gt;moveFrom('\/source\/file.md');   Duplicate a file within same directory  You must give the new name for the duplicated file.  $file_to_duplicate = FilePath::create('\/some\/file\/original.md'); $file_to_duplicate-&gt;to('clone.md')-&gt;copy('original.md');  ","tags":"","url":"FilePath.html"},{"title":"In the Loft Studios Library","text":"  A collection of open source code provided by In the Loft Studios, LLC. ","tags":"","url":"README.html"},{"title":"Dataset","text":"  An PHP class to use for data objects, using JSON schema as a validation structure.  Quick Start   Create a class that extends Dataset. Now define the json schema.  A simple method is to supply a class constant JSON_SCHEMA with the schema value:  class SimpleExample extends Dataset {    const JSON_SCHEMA = '{\"type\": \"object\",\"required\":[\"id\"],\"id\":{\"type\":\"integer\"},\"version\":{\"type\":\"string\",\"default\":\"1.2.5\"}}';  }    Most times however, your schema will live in a separate file.  Therefore you will not define the class constant JSON_SCHEMA, rather provide the path to the json schema as the return value of the public static method pathToJsonSchema.  You may follow the convention of appending .schema.json to the classname, if you wish, as shown here:  \/**  * {@inheritdoc}  *\/ protected static function pathToJsonSchema() {   return __DIR__ . '\/DatasetAlpha.schema.json'; }  Now create a json schema file to define your dataset at the path defined above.   Be aware that when you use the pattern keyword to define a regex expression that you do NOT include the delimiters like you do in PHP's preg_match.  This is corrent JSON: \"pattern\": \"\\\\?[^#]+\", notice there are no delimiters.  Then implement an instance in your code like this:  &lt;?php $data = ['id' =&gt; 123]; ... try {     $timer = Timer::dataset($data)-&gt;validate()-&gt;throwFirstProblem(); } catch (\\Exception $exception) {     \/\/ Do something if validation failed. }    Using PHP class members in your JSON code with static::  You can provide class methods, constants, etc in your JSON schema files and they will be evaluated at runtime.  For example, here we provide the regex pattern for the date property with a class constant, and the default value with a class method.  The cornerstone of this process is that the value begin with static::.      \"date\": {         \"type\": \"string\",         \"default\": \"static::defaultDate()\",         \"pattern\": \"static::REGEX_DATEISO8601\"     },   Accessing Data   Get the complete dataset as an array (sorted, with defaults, etc): $array = $data-&gt;get() Get the JSON value of the dataset by casting to a string: $json = strval($data). Use a property directly: $id = $data-&gt;id Use a property's alias directly: $id = $data-&gt;userId.  Read about aliases for more info.   Accessing Defaults   Get the default for single key: Timer::getDefault('id'). Get an array of defaults: Timer::getDefaults()   Detecting Errors   Return an array of all: $data-&gt;getProblems. Throw an \\InvalidArgumentException with the first problem: $data-&gt;throwFirstError   Setting Data   You can alter a single key using ::mutate.   Aliases  You may have aliases for property keys, which means you can access the same value using any of a number of keys.  To define an alias use colon separation as seen below:  {     ...     \"properties\": {         \"mi:me:moi\": {             \"default\": \"myself\",             \"type\": \"string\",             \"pattern\": \"\/^m.+\/\"         },   Custom Validation   If you have advanced validation beyond what comes for free, you may extend validate(), but read the docs there for what needs to happen. Consider using ignoreKey() instead, if possible.   How to Ignore a Key in Your Dataset (so as to not cause validation error)  protected static function ignoreKey($key) {     return $key === 'duration'; }  protected static function ignoreKey($key) {     return strpos($key, '#') === 0; }   Notes   To ignore some keys use static::ignoreKey() in your class.   Advanced Usage  Auto-generate Values: Example 1  The time to do this is during ::import.  &lt;?php  \/**  * Import extra data based on a default value.  *  * In this example, the defaults set the user id by global var.  During import  * we check for a user_id, either by import $data or the default data.  Then we  * make sure the the $original import data doesn't contain session_id, and if  * so we pull that data from the user account object.  *\/ class Alpha extends Dataset {    ...     \/**    * {@inheritdoc}    *\/   protected static function defaults() {     global $user;      return [       'user_id' =&gt; $user-&gt;uid,       'session_id' =&gt; -1,     ];   }    \/**    * {@inheritdoc}    *\/   public function import($data) {     $original = $data;     $data += static::getDefaults();      \/\/ Figure the session id based on the last time the user logged in.     \/\/ https:\/\/amplitude.zendesk.com\/hc\/en-us\/articles\/115002323627-Sessions     if ($data['user_id'] &amp;&amp; empty($original['session_id'])) {       $account = user_load($data['user_id']);        \/\/ We will count our session based on last login.       \/\/ https:\/\/drupal.stackexchange.com\/questions\/21864\/whats-the-difference-between-user-login-and-access#21873       $data['session_id'] = $account-&gt;login * 1000;     }      return parent::import($data);   }  }  ","tags":"","url":"dataset.html"},{"title":"Search Results","text":" ","tags":"","url":"search--results.html"}]};
